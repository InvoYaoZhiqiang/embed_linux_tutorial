.. vim: syntax=rst

位操作方法
-----

使用C语言对寄存器赋值时，我们常常要求只修改该寄存器或变量的某几位的值，且其它位不变，这个时候我们就需要用到C语言的位操作方法了。

把变量的某位清零
''''''''

此处我们以变量a代表寄存器，并假设寄存器中本来已有数值，此时需要把变量a的某一位清零，且其它位不变，方法见代码清单 65‑1。

代码清单 65‑1 对某位清零

1 //定义一个变量a = 1001 1111 b (二进制数)

2 unsigned char a = 0x9f;

3

4 //对bit2 清零

5

6 a &= ~(1<<2);

7

8 //括号中的1左移两位，(1<<2)得二进制数：0000 0100 b

9 //按位取反，~(1<<2)得1111 1011 b

10 //假如a中原来的值为二进制数： a = 1001 1111 b

11 //所得的数与a作"位与&"运算，a = (1001 1111 b)&(1111 1011 b),

12 //经过运算后，a的值 a=1001 1011 b

13 // a的bit2 位被被零，而其它位不变。

把变量的某几个连续位清零
''''''''''''

由于寄存器中有时会有连续几个寄存器位用于控制某个功能，现假设我们需要把寄存器的某几个连续位清零，且其它位不变，方法见代码清单 65‑2。

代码清单 65‑2 对某几个连续位清零

1

2 //若把a中的二进制位分成2个一组

3 //即bit0、bit1为第0组，bit2、bit3为第1组，

4 // bit4、bit5为第2组，bit6、bit7为第3组

5 //要对第1组的bit2、bit3清零

6

7 a &= ~(3<<2*1);

8

9 //括号中的3左移两位，(3<<2*1)得二进制数：0000 1100 b

10 //按位取反，~(3<<2*1)得1111 0011 b

11 //假如a中原来的值为二进制数： a = 1001 1111 b

12 //所得的数与a作"位与&"运算，a = (1001 1111 b)&(1111 0011 b),

13 //经过运算后，a的值 a=1001 0011 b

14 // a的第1组的bit2、bit3被清零，而其它位不变。

15

16 //上述(~(3<<2*1))中的(1)即为组编号;如清零第3组bit6、bit7此处应为3

17 //括号中的(2)为每组的位数，每组有2个二进制位;若分成4个一组，此处即为4

18 //括号中的(3)是组内所有位都为1时的值;若分成4个一组，此处即为二进制数"1111 b"

19

20 //例如对第2组bit4、bit5清零

21 a &= ~(3<<2*2);

对变量的某几位进行赋值。
''''''''''''

寄存器位经过上面的清零操作后，接下来就可以方便地对某几位写入所需要的数值了，且其它位不变，方法见代码清单 65‑3，这时候写入的数值一般就是需要设置寄存器的位参数。

代码清单 65‑3 对某几位进行赋值

1 //a = 1000 0011 b

2 //此时对清零后的第2组bit4、bit5设置成二进制数"01 b "

3

4 a |= (1<<2*2);

5 //a = 1001 0011 b，成功设置了第2组的值，其它组不变

对变量的某位取反
''''''''

某些情况下，我们需要对寄存器的某个位进行取反操作，即 1变0 ，0变1，这可以直接用如下操作，其它位不变，见代码清单 65‑4。

代码清单 65‑4 对某位进行取反操作

1 //a = 1001 0011 b

2 //把bit6取反，其它位不变

3

4 a ^=(1<<6);

5 //a = 1101 0011 b
